name: Deploy

on:
  workflow_call:
    inputs:
      git_commit_hash:
        required: true
        type: string
    secrets:
      DEPLOY_SSH_KEY:
        required: true
      DB_PASSWORD:
        required: true
      JWT_SECRET:
        required: true
      JWT_REFRESH_SECRET:
        required: true
      CLIENT_BASE_URL:
        required: true
      SMTP_HOST:
        required: true
      SMTP_PORT:
        required: true
      SMTP_USER:
        required: true
      SMTP_PASS:
        required: true
      SMTP_EMAIL:
        required: true
      STORAGE_TYPE:
        required: true
      BUCKET_ENDPOINT:
        required: true
      BUCKET_ACCESS_KEY_ID:
        required: true
      BUCKET_SECRET_ACCESS_KEY:
        required: true
      BUCKET_NAME:
        required: true
      BUCKET_REGION:
        required: true
      BUCKET_PUBLIC_URL:
        required: true
  workflow_dispatch:
    inputs:
      git_commit_hash:
        description: "Git commit hash to deploy (defaults to latest)"
        required: false
        type: string
        default: ""

permissions:
  contents: read

env:
  REGISTRY: ghcr.io
  OWNER: ${{ github.repository_owner }}
  REPO: ${{ github.event.repository.name }}

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ inputs.git_commit_hash || github.sha }}

      - name: Install dependencies
        run: |
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64
          sudo mv cloudflared-linux-amd64 /usr/local/bin/cloudflared
          sudo chmod +x /usr/local/bin/cloudflared
          sudo apt-get -qq update -y && sudo apt-get -qq install -y rsync &>/dev/null

      - name: Verify that the images exist
        env:
          TAG: ${{ inputs.git_commit_hash || github.sha }}
        run: |
          set -Eeuo pipefail
          RED="\033[31m"; GREEN="\033[32m"; YELLOW="\033[33m"; BLUE="\033[34m"; RESET="\033[0m"

          REPO_VAR="${REPO:-}"
          if [ -z "$REPO_VAR" ] && [ -n "${GITHUB_REPOSITORY:-}" ]; then
            REPO_VAR="${GITHUB_REPOSITORY#*/}"
          fi
          if [ -z "$REPO_VAR" ]; then
            REMOTE_URL=$(git config --get remote.origin.url 2>/dev/null || true)
            if [ -n "$REMOTE_URL" ]; then
              REPO_VAR=$(basename -s .git "$REMOTE_URL")
            fi
          fi
          if [ -z "$REPO_VAR" ]; then
            echo -e "${RED}Repository name not detected${RESET}"
            exit 1
          fi

          echo -e "${BLUE}Verifying container images (${TAG})${RESET}"
          services=("ai" "api" "client")
          missing=()
          for s in "${services[@]}"; do
            image="${REGISTRY}/${OWNER}/${REPO_VAR}-${s}:${TAG}"
            if docker manifest inspect "$image" >/dev/null 2>&1; then
              echo -e "${GREEN}  OK${RESET}  ${image}"
            else
              echo -e "${RED}  MISSING${RESET}  ${image}"
              missing+=("$image")
            fi
          done
          if [ "${#missing[@]}" -gt 0 ]; then
            echo -e "${RED}Missing images for tag ${TAG}${RESET}"
            for m in "${missing[@]}"; do echo "  - ${m}"; done
            exit 1
          fi
          echo -e "${GREEN}All required images present${RESET}"

      - name: Setup SSH
        id: setup_ssh
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          cat > ~/.ssh/config <<EOF
          Host revelo
            HostName ssh.revelo.app
            User deploy
            IdentityFile ~/.ssh/deploy_key
            StrictHostKeyChecking accept-new
            ProxyCommand cloudflared access ssh --hostname %h
            ServerAliveInterval 60
            ServerAliveCountMax 3
            TCPKeepAlive yes
          EOF
          chmod 600 ~/.ssh/config

          cat > ~/retry_ssh.sh <<'EOF'
          retry_ssh() {
            local max_attempts=3
            local delay=5
            local attempt=1
            while [ $attempt -le $max_attempts ]; do
              if ssh -q -o LogLevel=ERROR -T revelo "$@"; then
                return 0
              else
                if [ $attempt -lt $max_attempts ]; then
                  sleep $delay
                fi
              fi
              attempt=$((attempt + 1))
            done
            return 1
          }
          EOF
          chmod +x ~/retry_ssh.sh

      - name: Test connection
        run: |
          source ~/retry_ssh.sh
          retry_ssh true

      - name: Check and clean disk space
        run: |
          source ~/retry_ssh.sh
          retry_ssh << 'ENDSSH'
          set -Eeuo pipefail
          RED="\033[31m"; GREEN="\033[32m"; YELLOW="\033[33m"; BLUE="\033[34m"; RESET="\033[0m"

          available_gb=$(df -BG / | awk 'NR==2 {print $4}' | sed 's/G//')
          echo -e "${BLUE}Available disk space: ${available_gb}GB${RESET}"

          if [ "$available_gb" -lt 10 ]; then
            echo -e "${YELLOW}Low disk space, cleaning up${RESET}"
            
            docker container prune -f >/dev/null 2>&1
            docker image prune -f >/dev/null 2>&1
            docker network prune -f >/dev/null 2>&1
            available_gb=$(df -BG / | awk 'NR==2 {print $4}' | sed 's/G//')
            echo -e "${GREEN}Cleanup complete: ${available_gb}GB available${RESET}"
            if [ "$available_gb" -lt 10 ]; then
              echo -e "${RED}Insufficient space after cleanup${RESET}"
              exit 1
            fi
          fi
          ENDSSH

      - name: Prepare deployment files
        run: |
          mkdir -p deployment
          cp stack.yml deployment/
          cp -r nginx deployment/

          cat > deployment/.env <<EOF
          GIT_COMMIT_HASH=${{ inputs.git_commit_hash || github.sha }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}
          CLIENT_BASE_URL=${{ secrets.CLIENT_BASE_URL }}
          SMTP_HOST=${{ secrets.SMTP_HOST }}
          SMTP_PORT=${{ secrets.SMTP_PORT }}
          SMTP_USER=${{ secrets.SMTP_USER }}
          SMTP_PASS=${{ secrets.SMTP_PASS }}
          SMTP_EMAIL=${{ secrets.SMTP_EMAIL }}
          STORAGE_TYPE=${{ secrets.STORAGE_TYPE }}
          BUCKET_ENDPOINT=${{ secrets.BUCKET_ENDPOINT }}
          BUCKET_ACCESS_KEY_ID=${{ secrets.BUCKET_ACCESS_KEY_ID }}
          BUCKET_SECRET_ACCESS_KEY=${{ secrets.BUCKET_SECRET_ACCESS_KEY }}
          BUCKET_NAME=${{ secrets.BUCKET_NAME }}
          BUCKET_REGION=${{ secrets.BUCKET_REGION }}
          BUCKET_PUBLIC_URL=${{ secrets.BUCKET_PUBLIC_URL }}
          EOF

      - name: Copy files to server
        run: |
          source ~/retry_ssh.sh
          retry_ssh "mkdir -p ~/revelo"

          for attempt in 1 2 3; do
            if rsync -az --delete -e "ssh" deployment/ revelo:~/revelo/; then
              rm -rf deployment
              break
            else
              if [ $attempt -lt 3 ]; then
                echo "Rsync failed ($attempt/3). Retrying in 5s..."
                sleep 5
              else
                echo "Rsync failed after 3 attempts"
                rm -rf deployment
                exit 1
              fi
            fi
          done

      - name: Deploy stack
        run: |
          ssh -q -o LogLevel=ERROR -T revelo bash -s << 'ENDSSH'
          set -Eeuo pipefail
          RED="\033[31m"; GREEN="\033[32m"; YELLOW="\033[33m"; BLUE="\033[34m"; RESET="\033[0m"

          cd ~/revelo
          set -a && source .env && set +a
          rm -f .env

          if docker info --format '{{.Swarm.LocalNodeState}}' 2>/dev/null | grep -q inactive; then
            docker swarm init > /dev/null 2>&1
            echo -e "${YELLOW}Swarm initialized${RESET}"
          fi

          if docker stack ps revelo --format "{{.Name}}" 2>/dev/null | grep -q .; then
            echo -e "${BLUE}Updating revelo stack${RESET}"
          else
            echo -e "${BLUE}Deploying revelo stack${RESET}"
          fi

          output=$(mktemp)
          if ! docker stack deploy -c stack.yml revelo --detach=true >"$output" 2>&1; then
            sed 's/^/  /' "$output"
            echo -e "${RED}Stack deploy command failed${RESET}"
            rm -f "$output"
            exit 1
          fi

          sed 's/^/  /' "$output"

          if grep -Eiq '^[[:space:]]*service[[:space:]]+[^:]+:[[:space:]]' "$output"; then
            echo -e "${RED}One or more services failed to deploy/update${RESET}"
            rm -f "$output"
            exit 1
          fi
          if grep -Eiq '(error|failed)' "$output"; then
            echo -e "${RED}Errors detected during stack deploy${RESET}"
            rm -f "$output"
            exit 1
          fi

          rm -f "$output"
          echo -e "${GREEN}Stack deploy invoked${RESET}"
          ENDSSH

      - name: Verify deployment
        run: |
          source ~/retry_ssh.sh
          retry_ssh << 'ENDSSH'
          set -Eeuo pipefail
          RED="\033[31m"; GREEN="\033[32m"; YELLOW="\033[33m"; BLUE="\033[34m"; RESET="\033[0m"

          svc_exists() {
            docker service ls --format '{{.Name}}' | grep -qx "$1"
          }

          migrate_svc="revelo_migrate"
          if svc_exists "$migrate_svc"; then
            echo -e "Waiting for migration job"
            max_wait=600
            interval=5
            elapsed=0
            last_state=""
            while [ $elapsed -lt $max_wait ]; do
              raw_state=$(docker service ps "$migrate_svc" --no-trunc --format "{{.CurrentState}}" | head -1 || true)
              state="${raw_state%% *}"
              [ -z "$state" ] && state="pending"
              if [ "$state" != "$last_state" ]; then
                last_state="$state"
              fi
              if [ "$state" = "Complete" ]; then
                echo -e "${GREEN}Migration completed${RESET}"
                break
              fi
              if [ "$state" = "Failed" ] || [ "$state" = "Rejected" ]; then
                echo -e "${RED}Migration failed${RESET}"
                exit 1
              fi
              sleep $interval
              elapsed=$((elapsed + interval))
            done
            if [ $elapsed -ge $max_wait ]; then
              echo -e "${RED}Migration timed out${RESET}"
              exit 1
            fi
          else
            echo -e "${RED}Migration job not found${RESET}"
            exit 1
          fi

          echo -e "${BLUE}Checking services health${RESET}"
          services=(revelo_postgres revelo_nginx revelo_client revelo_api revelo_ai)
          max_wait=480
          interval=5
          elapsed=0
          prev_line=""

          while [ $elapsed -lt $max_wait ]; do
            all_ready=true
            any_bad=false
            line=""

            for name in "${services[@]}"; do
              if ! svc_exists "$name"; then
                line+=$(printf "%s: %s  " "$name" "${RED}not found${RESET}")
                any_bad=true
                continue
              fi

              expected_replicas=$(docker service inspect "$name" --format '{{.Spec.Mode.Replicated.Replicas}}' 2>/dev/null || echo "1")

              hc_enabled=$(docker service inspect "$name" --format '{{if .Spec.TaskTemplate.ContainerSpec.Healthcheck}}enabled{{else}}none{{end}}' 2>/dev/null || echo "none")

              failed_tasks=$(docker service ps "$name" --filter "desired-state=running" --format "{{.CurrentState}}" --no-trunc | grep -E "(Failed|Rejected)" || true)
              if [ -n "$failed_tasks" ]; then
                line+=$(printf "%s: %s  " "$name" "${RED}failed${RESET}")
                any_bad=true
                continue
              fi

              healthy_count=0
              starting_count=0
              unhealthy_count=0

              if [ "$hc_enabled" = "enabled" ]; then
                while IFS= read -r task_id; do
                  if [ -n "$task_id" ]; then
                    cid=$(docker ps -q --filter "label=com.docker.swarm.task.id=$task_id" 2>/dev/null | head -1 || true)
                    if [ -n "$cid" ]; then
                      health=$(docker inspect "$cid" --format '{{.State.Health.Status}}' 2>/dev/null || echo "starting")
                      case "$health" in
                        healthy)   healthy_count=$((healthy_count + 1)) ;;
                        starting)  starting_count=$((starting_count + 1)) ;;
                        unhealthy) unhealthy_count=$((unhealthy_count + 1)) ;;
                      esac
                    else
                      starting_count=$((starting_count + 1))
                    fi
                  fi
                done < <(docker service ps "$name" --filter "desired-state=running" --format "{{.ID}}" --no-trunc 2>/dev/null)
              else
                healthy_count=$(docker service ps "$name" --filter "desired-state=running" --format "{{.ID}}" 2>/dev/null | wc -l)
              fi

              if [ "$unhealthy_count" -gt 0 ]; then
                line+=$(printf "%s: %s/%s %s  " "$name" "$healthy_count" "$expected_replicas" "${RED}unhealthy${RESET}")
                any_bad=true
              elif [ "$healthy_count" -eq "$expected_replicas" ]; then
                line+=$(printf "%s: %s/%s %s  " "$name" "$healthy_count" "$expected_replicas" "${GREEN}healthy${RESET}")
              else
                line+=$(printf "%s: %s/%s %s  " "$name" "$healthy_count" "$expected_replicas" "${YELLOW}starting${RESET}")
                all_ready=false
              fi
            done

            if [ "$line" != "$prev_line" ] || [ $elapsed -eq 0 ]; then
              echo -e "  $line"
              prev_line="$line"
            fi

            if [ "$any_bad" = true ]; then
              echo -e "${RED}One or more services in bad state${RESET}"
              exit 1
            fi

            if [ "$all_ready" = true ]; then
              echo -e "${GREEN}All services healthy${RESET}"
              exit 0
            fi

            sleep $interval
            elapsed=$((elapsed + interval))
          done

          echo -e "${RED}Timeout after ${max_wait}s${RESET}"
          exit 1
          ENDSSH

      - name: Post-deployment cleanup
        if: success()
        run: |
          source ~/retry_ssh.sh
          retry_ssh << 'ENDSSH'
          set -Eeuo pipefail
          RED="\033[31m"; GREEN="\033[32m"; YELLOW="\033[33m"; BLUE="\033[34m"; RESET="\033[0m"

          echo -e "${BLUE}Cleaning up old images${RESET}"
          for service in ai api client; do
            docker images --format "{{.ID}} {{.Repository}} {{.CreatedAt}}" | \
              grep "ghcr.io/jancernik/revelo-${service}" | \
              sort -k3 -r | \
              awk 'NR>3 {print $1}' | \
              xargs -r docker rmi -f 2>/dev/null || true
          done
          echo -e "${GREEN}Cleanup complete${RESET}"
          ENDSSH

      - name: Save failure logs
        if: failure() && steps.setup_ssh.conclusion == 'success'
        run: |
          source ~/retry_ssh.sh
          echo "Capturing logs"
          retry_ssh << 'ENDSSH'
          set -Eeuo pipefail
          rm -f ~/revelo/.env
          mkdir -p ~/revelo/logs
          log_file=~/revelo/logs/deploy-$(date +%Y%m%d-%H%M%S).log

          {
            echo "deployment failed at $(date)"
            echo "----------------------------------------"
            for service in revelo_postgres revelo_nginx revelo_client revelo_api revelo_ai revelo_migrate; do
              status=$(docker service ps "$service" --no-trunc --format "{{.CurrentState}}" 2>/dev/null | head -1 || true)
              echo ""
              echo "service: $service"
              if [ -z "$status" ]; then
                echo "status: not found"
              else
                echo "status: $status"
              fi
              echo ""
              docker service logs "$service" --tail 200 --no-task-ids 2>&1 || echo "no logs"
              echo "----------------------------------------"
            done
          } > "$log_file"

          echo "Logs saved to: $log_file"
          ENDSSH

      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key ~/.ssh/config ~/retry_ssh.sh || true
          rm -rf deployment || true

          if [ -f ~/retry_ssh.sh ]; then
            source ~/retry_ssh.sh
            retry_ssh "rm -f ~/revelo/.env" || true
          fi
